package handlers

import (
	"html/template"
	"log/slog"
	"net/http"
	"strconv"

	"github.com/gorilla/csrf"
	"golang.org/x/oauth2"

	"github.com/shark-ci/shark-ci/internal/server/db"
	"github.com/shark-ci/shark-ci/internal/server/middleware"
	"github.com/shark-ci/shark-ci/internal/server/service"
	"github.com/shark-ci/shark-ci/internal/server/store"
	"github.com/shark-ci/shark-ci/templates"
)

type RepoHandler struct {
	s        store.Storer
	services service.Services
}

func NewRepoHandler(s store.Storer, services service.Services) *RepoHandler {
	return &RepoHandler{
		s:        s,
		services: services,
	}
}

func (h *RepoHandler) HandleRepos(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()
	user, ok := middleware.UserFromContext(ctx, w)
	if !ok {
		return
	}

	repos, err := h.s.GetReposByUser(ctx, user.ID)
	if err != nil {
		slog.Error("Cannot get user repos", "userID", user.ID, "err", err)
	}
	// TODO: Split repos by service

	templates.ReposTmpl.Execute(w, struct {
		CSRFField template.HTML
		Repos     []db.Repo
	}{
		CSRFField: csrf.TemplateField(r),
		Repos:     repos,
	})
}

func (h *RepoHandler) HandleRegisterRepo(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	r.ParseForm()
	repoIDString := r.Form.Get("repo_id")
	repoID, err := strconv.ParseInt(repoIDString, 10, 64)
	if err != nil {
		slog.Error("Cannot parse repo_id", "id", repoIDString, "err", err)
		w.WriteHeader(http.StatusBadRequest)
		return

	}

	info, err := h.s.GetRegisterWebhookInfoByRepo(ctx, repoID)
	if err != nil {
		slog.Error("Cannot get webhook info by repo", "repoID", repoID, "err", err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}
	token := &oauth2.Token{
		AccessToken:  info.AccessToken,
		RefreshToken: info.RefreshToken.String,
		TokenType:    info.TokenType,
		Expiry:       info.TokenExpire.Time,
	}

	srv, ok := h.services[string(info.Service)] // TODO: Change h.services to accept enum generated by db.
	if !ok {
		slog.Error("Unknown service", "service", info.Service)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	webhookID, err := srv.CreateWebhook(ctx, token, info.Owner, info.Name)
	if err != nil {
		slog.Error("Cannot create webhook", "repoID", repoID, "err", err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	err = h.s.UpdateRepoWebhook(ctx, repoID, &webhookID)
	if err != nil {
		slog.Error("Cannot update repo webhook", "repoID", repoID, "err", err)
		w.WriteHeader(http.StatusInternalServerError)
		return
	}

	http.Redirect(w, r, "/repositories", http.StatusFound)
}

//func (h *RepoHandler) HandleUnregisterRepo(w http.ResponseWriter, r *http.Request) {
//	ctx := r.Context()
//	serviceUser, repo, srv, err := h.getInfoFromRequest(ctx, w, r)
//	if err != nil {
//		slog.Error("cannot get info from request", "err", err)
//		w.WriteHeader(http.StatusInternalServerError)
//		return
//	}
//
//	err = srv.DeleteWebhook(ctx, serviceUser, repo)
//	if err != nil {
//		slog.Error("service: cannot delete webhook", "err", err)
//		w.WriteHeader(http.StatusInternalServerError)
//		return
//	}
//
//	err = h.s.UpdateRepoWebhook(ctx, repo)
//	if err != nil {
//		slog.Error("store: cannot update webhook", "err", err)
//		w.WriteHeader(http.StatusInternalServerError)
//		return
//	}
//
//	http.Redirect(w, r, "/repositories", http.StatusFound)
//}
//
//func (h *RepoHandler) HandleActivateRepo(w http.ResponseWriter, r *http.Request) {
//	h.changeRepoState(w, r, true)
//}
//
//func (h *RepoHandler) HandleDeactivateRepo(w http.ResponseWriter, r *http.Request) {
//	h.changeRepoState(w, r, false)
//}
//
//func (h *RepoHandler) changeRepoState(w http.ResponseWriter, r *http.Request, active bool) {
//	ctx := r.Context()
//	serviceUser, repo, srv, err := h.getInfoFromRequest(ctx, w, r)
//	if err != nil {
//		slog.Error("cannot get infor from request", "err", err)
//		http.Error(w, err.Error(), http.StatusBadRequest)
//		return
//	}
//
//	repo, err = srv.ChangeWebhookState(ctx, serviceUser, repo, active)
//	if err != nil {
//		slog.Error("service: cannot change a webhook state", "err", err)
//		w.WriteHeader(http.StatusInternalServerError)
//		return
//	}
//
//	err = h.s.UpdateRepoWebhook(ctx, repo)
//	if err != nil {
//		slog.Error("store: cannot update a webhook", "err", err)
//		w.WriteHeader(http.StatusInternalServerError)
//		return
//	}
//
//	http.Redirect(w, r, "/repositories", http.StatusFound)
//}

//func (h *RepoHandler) getInfoFromRequest(ctx context.Context, w http.ResponseWriter, r *http.Request) (*models.ServiceUser, *models.Repo, service.ServiceManager, error) {
//	user, ok := middleware.UserFromContext(ctx, w)
//	if !ok {
//		return nil, nil, nil, errors.New("unauthorized user")
//	}
//
//	r.ParseForm()
//	repo, err := h.s.GetRepo(ctx, r.Form.Get("repo_id"))
//	if err != nil {
//		return nil, nil, nil, err
//	}
//
//	srv, ok := h.services[repo.ServiceName]
//	if !ok {
//		return nil, nil, nil, fmt.Errorf("unknown service: %s", repo.ServiceName)
//	}
//
//	serviceUser, err := h.s.GetServiceUserByUser(ctx, user, repo.ServiceName)
//	if err != nil {
//		return nil, nil, nil, err
//	}
//
//	return serviceUser, repo, srv, nil
//}
//
//func splitRepos(repos []*models.Repo) ([]*models.Repo, []*models.Repo) {
//	registered := []*models.Repo{}
//	notRegistered := []*models.Repo{}
//	for _, repo := range repos {
//		if repo.WebhookID == 0 {
//			notRegistered = append(notRegistered, repo)
//		} else {
//			registered = append(registered, repo)
//		}
//	}
//	return registered, notRegistered
//}
